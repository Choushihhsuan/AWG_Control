# AWG Control -- Python file
> This folder contains the python files used to control the <mark>M4i-6622.x8 AWG</mark> used in the lab. 
> After I modified my original programs and combine similar programs in the original version, the following three python programs will do all the works to control the AWG. But please be aware that these programs are definitely subject to further modifications if new functionalities, such as external trigger, are to be added.

The files are:
1. generate_freq_list_20220505.py
2. complete_control_20220504.py
3. aux_functions_20220504.py

Note that the files were still modified after the date in their file names, yet I did not change the file names as a means of version control and also to prevent possible errors when importing functions between the files.

Also note that a file overview is included in each file listed above for the users' ease of reference.


## Function Description in each Files
### 1. generate_freq_list_20220505.py: 
* The file where the user **specifies the coordinate movement list and other parameters to generate the frequency control list**. The parameters that the user should specify are 
    * sampling rate (R)
    * the frequency that corresponds to the origin of the coordinate (central_frequency)
    * the difference in frequency that corresponds to one unit of coordinate shift (lattice_spacing)
    * the time it takes a light beam to move one unit of coordinate (transit_time)
    * the output file names (out_file_1/2). 

* The user should note that the coordinate movement list (process_list) can not only be specified by the user explicitly, but also be generated by some external functions that computes certain movement steps.

### 2. complete_control_20220504.py:
* This file is the one that communicates with the AWG, read in the signal frequency information, and generates the required waveform. 
* This program reads in the settings from the files generated by "generate_freq_list_20220505.py" to automatically calculates the size of the buffer being used and configure the card accordingly. 
* Since the number of output channels should be two for this program, and the current output voltage level written in the program works just fine, **the user do not have to do much in this program**. A few possible exceptions might be changing the **trigger settings** to accommodate external trigger or changing the data replay mode.

### 3. aux_functions_20220504.py:
* This file contains all the auxiliary functions, which are called in both "generate_freq_list_20220505.py" and "complete_control_20220504.py". A brief description for each function is given below (detailed description is included in the comments in the source code).
    * read_setup_from_txt: Used in "complete_control_20220504.py". This function reads in the setups and waveform parameters from the setting file generated by "generate_freq_list_20220505.py". 
    * cubic_interp_freq_list: Generates the cubic-interpolated frequency list used in "complete_control_20220504.py". Note that the interpolation method may be altered in the future if a better option is found. 
    * The rest of the functions are used in "generate_freq_list_20220505.py" to generate the frequency list file from the user specified parameters and movement steps (in corredinate form).


    > Note that the files: <mark>spcm_tools.py, pyspcm.py, regs.py, and spcerr.py</mark> are setup files provided by the AWG manufacturer. These files <mark>should not be changed without necessary purposes</mark>.


### 4. moving_algorithm_2022_may.ipynb
* Contains the algorithm to form a full array after the atoms are loaded onto the SLM "backbone". This jupyter notebook contains the code to simulate the full process from atom loading to forming an array. The flow goes as
    *  form an random array partially filled with atoms
    *  Determine where to form the completely filled "core" array, and accumulate the atoms around to ensure that each row in the core array contains enough atoms (presorting)
    *  rearrange the atoms in each row of the core array to form a rectangular (or square), completely filled atom array.

* Functions:
    * fill_atoms: generates a partially and randomly filled array of specified size with specified filling ratio. The user may play around with different settings of dimensions and filling ratio to test their effects on the number of movements in the following steps. 
    * pre_sorting: a process that ensures each row in the core array has enough atoms. Note that by default, the core array is set to be formed in the middle of the whole array. If the location of the core array is to be changed, then the source code should be modified. Note that the idea of this step comes from an article from Lukin's group.
    * form_core_array: after presorting is done, this function takes the resulting array and reshuffle the atom of each row in the core array to move them to the middle, thus forming a closely packed array in the center. This sort of dreshuffling movement within a row is supported by the AWG control program, so the reshuffling can be done in one step of movement. 
    *The rest of the functions are auxiliary functions that support the functioning of "pre_sorting" and "form_core_array".
    > Please note that in both "pre_sorting" and "form_core_array", the functions return a parameter called "movement_return_list". This "movement_return_list" contains all the required steps to transform the input lattice array into the final lattice array in each section. The format of the list is also compatible to the one used in "generate_freq_list_20220505.py", so the output movement lists can be input into the python file and generate the corresponding frequency files.
    
    > This jupyter notebook also contains a section in the end that investigates the distribution of number of movement steps with different array sizes and filling ratio.




